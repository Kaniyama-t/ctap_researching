> 本ファイルは、fido alliance様が公開なさっている"Client to Authenticator Protocol (CTAP) Proposed Standard, January 30, 2019"を勝手に自己解釈しているものです。信ぴょう性はありません。ご了承ください。
> 正しい情報は以下リンクよりご参照ください、

src: https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.html

8.1 USBに関する物理層の規格

# 8.1.1 定義根拠

CTAP messagesはHIDプロトコルを用いたUSB通信にフレーム化されています。私たちは今後、この定義をCTAPHIDと呼びます。CTAPHIDプロトコルはオブジェクト指向の設計に従って設計されます。

(原文：The CTAPHID protocol is designed with the following design objectives in mind)

- ドライバのインストールが不必要であり、すべてのメジャープラットフォームで動作します。
- ストリーム通信やパケットの集約無しに複数のアプリケーションによるアクセスをサポートします(?)
- 固定遅延応答(?)と古いプロトコルをオーバーヘッドします

~~中断パケットとしてHIDデータが送られている最中かつ複数のアプリケーションによるHID Stackへのアクセスは、~~ HIDデータは割り込みパケットとして送信され、複数のアプリケーションが一度にHIDスタックにアクセスする可能性があるため、これを処理するために複雑なレベルを追加する必要があります。

# 8.1.2 プロトコルの構造とデータのフレーム化の定義

CTAPプロトコルは直前の動作に依存することなく，かつ並列で処理が出来るよう設計されています。

CTAPHIDプロトコルでは、以下のフレームに分けた設計を行います

- Transaction
  高レベルな機能(リクエスト)の集合体
  リクエストとそれに続く応答メッセージで構成
  2つめのトランザクションを実行する前に、現在のトランザクションを完全に完了|中止させる必要あり
  CTAPプロトコル層に位置

- Messages
  Transactionを構成する"リクエスト"と"応答メッセージ"のことです。
  HID Reportsに位置

- Packets
  Messagesを順番に特定のbitに分割したものです。
  CTAPHIDではPacketsを最小の単位としています。

  HIDReportsに位置

# 8.1.3 並列化とチャンネル

CTAPHIDデバイスを複数のクライアントに分割することを許可するにはには、付加的なロジックとOverhead(?)が必要です。例えば、並列にアプリケーションが実行され、HID Stackを通して同一リソースに同時にアクセスする場合、CTAPHIDデバイスはロジカルなチャンネルを通じて複数のクライアントと通信を行います。この時、アプリケーション(ホスト側)は32bitのユニークなchannel識別子を使用します。

このchannel識別子は、そのユニーク性を失わないように、FIDO Authenticatorによって割り当てられます。現状、このchannel識別子生成アルゴリズムは製造元(ベンダー)に依存し、そしてこのドキュメントには定義しません。

ChannelID "0"は予約されており、0xffffffffはbroadcatsとして予約されています。0xffffffffの使い道としては、チャンネル割り当て時に使用するなどがあります。

# 8.1.4  メッセージとパケットの構造

パケットは**初期化パケット**と**継続パケット**の２つの種類に分かれています。最初に送られるパケットが初期化パケットで、Transactionの開始を通知する役割**も**もちます。この時、１つのパケットにデータが収まりきらなかった場合、１つないし複数の継続パケットが、厳格な昇順で、送信が完了されるまで送られます。

既知の通り、メッセージがホストからデバイスへ送られることをリクエスト、メッセージがデバイスからホストに送り返されることをレスポンスと言います。リクエストは、**応答を常にトリガーしており、**~~絶対に何かに対する引き金として定義されており~~ 、レスポンスとしてデバイスがad-hoc(その場しのぎのレスポンス)を送るようなことは決してありません。, i.e. without a prior request message.ただし、keep-aliveメッセージだけは、リクエストとレスポンスの間に送ることが出来ます。

リクエストとメッセージは同一の構造を持っています。とあるリクエストのinitializationパケットが内包されたTransactionが送られ~~ると~~、**レスポンスメッセージの最後のパケットで終了します**~~レスポンスメッセージのパケットが送られなくなります~~。また、Transactuibを開始するクライアントがこれを中断する場合があります。

Packetsのサイズは、エンドポイントとHID report descriptionによって定義された値により、**常に**固定されます。しかし、ほとんどのパケットはすべてのbyteを必要としません。しかし、本規格ではフルサイズでの送受信が必要となります。その為、使用しないbyteには0をセットしてください。

## [def] initialization packet

| Offset(Byte目) | 長さ(Byte) | 略名  |               説明               |
| :------------: | :--------: | :---: | :------------------------------: |
|       0        |     4      |  CID  |          Channel識別子           |
|       4        |     1      |  CMD  | Command識別子 (bit 7 always set) |
|       5        |     1      | BCNTH |    高いレベルなpayloadの長さ     |
|       6        |     1      | BCNTL |    低いレベルなpayloadの長さ     |
|       7        |  (s - 7)   | DATA  |          Payloadデータ           |

※ sはエンドポイントとHID Reportsで定義されている固定パケットサイズ

CMD(Command識別子)は、続いて送られる継続パケットと区別する為に、常に最上位ビットがセットされています。

## [def] continuation packet

| Offset(Byte目) | 長さ(Byte) | 略称 |                   説明                   |
| :------------: | :--------: | :--: | :--------------------------------------: |
|       0        |     4      | CID  |              Channel識別子               |
|       4        |     1      | SEQ  | Packet通し番号0x00..0x7f (7bit目は常に0) |
|       5        |  (s - 5)   | DATA |              Payloadデータ               |

※sはinitialization packetと同一値

このような試みは、ペイロードが設定されていないメッセージまたはDATAに収まるサイズのペイロードは、initialization packetとして１つのパケットで送られます。一方、initialization packetsに収まりきらないペイロードをもつメッセージは、1つないし複数のcontinuation packetsに分割され、0~127の通し番号を付与されて送信されます。

もし、エンドポイント等で定義さえている固定パケットのサイズが64bit(full-speedデバイスの最大サイズ)だとすると、メッセージの最大サイズは64 - 7 + 128 * (64 - 5) = 7609 bytes となります。

# 8.1.5 裁定

　複数のチャンネルとクライアントを管理しするために、CTAPHIDプロトコルは内部状況を維持し、リクエストの衝突をブロックし、完璧なプロトコルを維持しなければなりません。本プロトコルは、クライアントアプリケーションが正常に依存しなければ正常に動作しません。例えば、他のチャンネルを積極的に破壊する実装はNGです。そんなわけで、有害な、あるいは破損したアプリケーションの使用は、他のチャンネルの問題を引き起こす可能性があります。予期できるエラーや潜在的な問題を抱えるアプリケーションは適切に処理する必要があります。

## 8.1.5.1 Transactionのビジー状態とアイドル状態

　Transactionは常に3段階からなります．

1. ホストからデバイスにメッセージが送られる

2. デバイスはメッセージを処理する

3. レスポンスがデバイスからホストに帰ってくる

　~~このプロトコルでは、大抵の複数のアプリケーションは、常に急場の対応をする可能性がありますビルドされていると仮定します。~~

　このプロトコルは、複数の同時アプリケーションがいつでもアドホックにトランザクションを実行し、各トランザクションがアトミックである、つまり一度起動すると別のアプリケーションによって中断されないという前提に基づいて構築されています。

　デバイスがアイドル状態時の最初のパケットを通り抜ける為に管理するアプリケーションのチャンネルは、レスポンスの最終パケットが受け取られるか、そのTransactionが中断されるまで、他のチャンネルの為にデバイスをロックしたままにします。アイドル状態を返したデバイスは、もう一つの同一無いし違うチャンネルのTransactionの動作をする用意があります。これら2つのTransactionは、ステータスが無い状態ではデバイスが維持され、ホストアプリケーションは他のプロセスが他のTransaction上で常に動作していると判断します。

　もしアプリケーションが、他のTransactionとの通信でビジー状態の中、別のチャンネルを介しデバイスにアクセスを試みた(リクエストを送信した)場合、そのリクエストは直ちにビジー状態エラーがリクエストを送信したチャンネルに送られます。

## 8.1.5.2 Transactionのタイムアウト

　Transactionは、デバイスが他のアプリケーションからのアクセスを完全に遮断するのを予防する為、明示された期限に内で完了させなければなりません。たとえば、アプリケーションが初期化パケットを送信し、継続パケットが続き、そのアプリケーションがクラッシュすることを知らせる場合、デバイスは保留中のチャネル要求をバックアウトし、アイドル状態に戻ります。

## 8.1.5.3 Transactionの却下・再生成

もし、通信エラー等で期待されないレスポンスないしエラーを得た場合、abort-and-ecynchronizeコマンドを常時発行します。もし、Transactionが有効なうちに、ID並びchannelが同一なINIT Commandをデバイスが認識できれば、Transactionは中止され、バッファデータはフラッシュされます。デバイスがアイドル状況を返したタイミングで、新しいTransactionが準備されます。

## 8.1.5.4 順列のパケット

~~パケットの正確な伝達と昇順送信により、到着順を維持しかつパケットの破損を防がなければなりません。~~

デバイスは、到着するパケットを正しい昇順で追跡し、予想されるパケットが欠落していないことを追跡します。

デバイスは、Transactionがタイムアウトするか、Messageが完全になるまでパケットの収集を継続します。偽の継続パケットは、初期パケットが送信された後でない限り無視されます。

# 8.1.6 チャンネルロック

ベンダー特有の定義のコマンドによるトンネリングなど、Transactionの集合体を中断せず分解させるために、チャンネルロックコマンドが追加されています。チャンネルロックコマンドを送信することにより、デバイスは他のチャンネルを遮断します。この動作は、channel-lockがTimeoutするか、アプリケーションが明示的にロックを外すまで継続します。

この機能(挙動)はオプションであり、一般的なCTAP HID applicationでは考える必要はありません。

# 8.1.7 プロトコルバージョンと互換性

CTAP HIDプロトコルはbackwardsの互換性を維持しながら、適当な範囲で拡張する余地のあるようデザインされています。 ~~おり、拡張は適当です(???)。~~ これはCTAPHIDホストが、特定のバージョン独自の仕様を含むすべてのバージョンをサポートすることが望ましいことを意味します。