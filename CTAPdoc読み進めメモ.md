8.1 USBに関する物理層の規格

# 8.1.1 定義根拠

CTAP messagesはHIDプロトコルを用いたUSB通信にフレーム化されています。私たちは今後、この定義をCTAPHIDと呼びます。CTAPHIDプロトコルはオブジェクト指向の設計に従って設計されます。

(原文：The CTAPHID protocol is designed with the following design objectives in mind)

- ドライバのインストールが不必要であり、すべてのメジャープラットフォームで動作します。
- ストリーム通信やパケットの集約無しに複数のアプリケーションによるアクセスをサポートします(?)
- 固定遅延応答(?)と古いプロトコルをオーバーヘッドします

~~中断パケットとしてHIDデータが送られている最中かつ複数のアプリケーションによるHID Stackへのアクセスは、~~ HIDデータは割り込みパケットとして送信され、複数のアプリケーションが一度にHIDスタックにアクセスする可能性があるため、これを処理するために複雑なレベルを追加する必要があります。

# 8.1.2 プロトコルの構造とデータのフレーム化の定義

CTAPプロトコルは直前の動作に依存することなく，かつ並列で処理が出来るよう設計されています。

CTAPHIDプロトコルでは、以下のフレームに分けた設計を行います

- Transaction
  高レベルな機能(リクエスト)の集合体
  リクエストとそれに続く応答メッセージで構成
  2つめのトランザクションを実行する前に、現在のトランザクションを完全に完了|中止させる必要あり
  CTAPプロトコル層に位置

- Messages
  Transactionを構成する"リクエスト"と"応答メッセージ"のことです。
  HID Reportsに位置

- Packets
  Messagesを順番に特定のbitに分割したものです。
  CTAPHIDではPacketsを最小の単位としています。

  HIDReportsに位置

# 8.1.3 並列化とチャンネル

CTAPHIDデバイスを複数のクライアントに分割することを許可するにはには、付加的なロジックとOverhead(?)が必要です。例えば、並列にアプリケーションが実行され、HID Stackを通して同一リソースに同時にアクセスする場合、CTAPHIDデバイスはロジカルなチャンネルを通じて複数のクライアントと通信を行います。この時、アプリケーション(ホスト側)は32bitのユニークなchannel識別子を使用します。

このchannel識別子は、そのユニーク性を失わないように、FIDO Authenticatorによって割り当てられます。現状、このchannel識別子生成アルゴリズムは製造元(ベンダー)に依存し、そしてこのドキュメントには定義しません。

ChannelID "0"は予約されており、0xffffffffはbroadcatsとして予約されています。0xffffffffの使い道としては、チャンネル割り当て時に使用するなどがあります。

# 8.1.4  メッセージとパケットの構造

パケットは**初期化パケット**と**継続パケット**の２つの種類に分かれています。最初に送られるパケットが初期化パケットで、Transactionの開始を通知する役割**も**もちます。この時、１つのパケットにデータが収まりきらなかった場合、１つないし複数の継続パケットが、厳格な昇順で、送信が完了されるまで送られます。

既知の通り、メッセージがホストからデバイスへ送られることをリクエスト、メッセージがデバイスからホストに送り返されることをレスポンスと言います。リクエストは、**応答を常にトリガーしており、**~~絶対に何かに対する引き金として定義されており~~ 、レスポンスとしてデバイスがad-hoc(その場しのぎのレスポンス)を送るようなことは決してありません。, i.e. without a prior request message.ただし、keep-aliveメッセージだけは、リクエストとレスポンスの間に送ることが出来ます。

リクエストとメッセージは同一の構造を持っています。とあるリクエストのinitializationパケットが内包されたTransactionが送られ~~ると~~、**レスポンスメッセージの最後のパケットで終了します**~~レスポンスメッセージのパケットが送られなくなります~~。また、Transactuibを開始するクライアントがこれを中断する場合があります。

Packetsのサイズは、エンドポイントとHID report descriptionによって定義された値により、**常に**固定されます。しかし、ほとんどのパケットはすべてのbyteを必要としません。しかし、本規格ではフルサイズでの送受信が必要となります。その為、使用しないbyteには0をセットしてください。

## [def] initialization packet

| Offset(Byte目) | 長さ(Byte) | 略名  |               説明               |
| :------------: | :--------: | :---: | :------------------------------: |
|       0        |     4      |  CID  |          Channel識別子           |
|       4        |     1      |  CMD  | Command識別子 (bit 7 always set) |
|       5        |     1      | BCNTH |    高いレベルなpayloadの長さ     |
|       6        |     1      | BCNTL |    低いレベルなpayloadの長さ     |
|       7        |  (s - 7)   | DATA  |          Payloadデータ           |

※ sはエンドポイントとHID Reportsで定義されている固定パケットサイズ

CMD(Command識別子)は、続いて送られる継続パケットと区別する為に、常に最上位ビットがセットされています。

## [def] continuation packet

| Offset(Byte目) | 長さ(Byte) | 略称 |                   説明                   |
| :------------: | :--------: | :--: | :--------------------------------------: |
|       0        |     4      | CID  |              Channel識別子               |
|       4        |     1      | SEQ  | Packet通し番号0x00..0x7f (7bit目は常に0) |
|       5        |  (s - 5)   | DATA |              Payloadデータ               |

※sはinitialization packetと同一値

このような試みは、ペイロードが設定されていないメッセージまたはDATAに収まるサイズのペイロードは、initialization packetとして１つのパケットで送られます。一方、initialization packetsに収まりきらないペイロードをもつメッセージは、1つないし複数のcontinuation packetsに分割され、0~127の通し番号を付与されて送信されます。

もし、エンドポイント等で定義さえている固定パケットのサイズが64bit(full-speedデバイスの最大サイズ)だとすると、メッセージの最大サイズは64 - 7 + 128 * (64 - 5) = 7609 bytes となります。